{
    "collab_server" : "",
    "contents" : "---\ntitle: \"`tidyr` lesson\"\noutput: github_document \n---\n\n```{r, include = F}\nlibrary(tidyr)\nlibrary(dplyr)\n```\n\n## What is tidy data?\n\nA large chunk of your time working with data in `r` is going to be spent cleaning and preparing data. *Tidy* data is a standardized way of organizing data; it was proposed by Hadley Wickham and is designed to make you more effective at exploring and analyzing your data. \n\nData is *tidy* if it is in a table that follows these rules: \n\n* Each column is a variable\n* Each row is an observation*\n\nIn practical terms this largely translates into getting each variable into it's own column. `tidyr` helps you do this, but more broadly, `tidyr` gives you a set of functions to manipulate dataframes. \n\n### Why tidy data?\n\n* structuring dataframes in a consistent way will make you faster at extracting the information you are intersted in.\n* `dplry` and `ggplot2` and other packages in the tidyverse are  designed to work with tidy data. \n\n* becoming proficient at manipulating dataframes is one of the most important r skills you can develop. \n\n## Example of tidy data\n\n```{r}\n#table1 is tidy\ntable1\n```\n\n## Examples of non-tidy data\n\nNon-tidy data typically has one of two problems but it can have both.\n\n* Variables are spread across multiple columns.\n* Observations are scattered across multiple rows.\n\n### Variables spread across multiple columns\n\n```{r}\ntable4a \n```\n\n###Observations scattered across multiple rows\n\n```{r}\ntable2\n```\n\n\n## Gathering and spreading\n\n`gather()` and `spread()` are functions desinged to help you tidy your data by addressing these two common problems.\n\n### `gather()`\n\n`gather()` lets you gather variables that are spread across multiple colunms (i.e. make long/tall dataframes). \n\n```{r}\ntable4a\n```\n\nConceptually, we want to gather up the two variables `1999` and `2000` into a single variable and create a new variable, `year`, to track which year that case comes from (i.e. 1999 vs 2000).\n\n```{r}\n#key is a new variable that tracks which year a value comes from\n\n#value is a new variable that will contain all the data that we gather into a siginle column (i.e. the cases)\n\n#verbose version\ngather(data = table4a, key = year, value = cases, `1999`, `2000`)\n\n#piped version; note the use of -country to specify columns to gather\ntable4a %>% \n  gather(year, cases, -country)\n\n```\n\n### `spread()`\n\n`spread()` is the inverse of gather; it lets you spread observations that are scattered across multiple rows (i.e. make wide dataframes).  \n\n```{r}\ntable2\n```\n\nConceptually, we want to create two new columns in our dataframe that represent the variables `cases` and `population`, and we want to fill those variables with the appropriate values from the `count` variable.\n\n```{r}\n#key = column that contains the variable names that we want to create\n#value = column that contain that values to go into those variables \n\n#verbose version\nspread(data = table2, key = type, value = count)\n\n#piped version\ntable2 %>% \n  spread(type, count)\n\n```\n\n\n### Challenge problem 1\n\n1. In `table4b`, year is spread across two columns. \n    a) Do you need `gather()` or `spread()` to tidy this data?\n    b) Create a tidy dataframe from `table4b`.\n    c) Once the data is tidy, find out the overall mean for tb cases.\n    d) Using the tidy and non-tidy dataframes find the mean tb cases for each year. How do the two approaches (non-tidy vs. tidy) compare? \n\n##Seperating and uniting\n\n###`seperate()`\n\n`seperate()` splits a column into multiple columns. \n\n```{r}\ntable3\n\n#verbose version\nseparate(data = table3, col = rate, \n         into = c(\"cases\", \"population\"), sep = \"/\")\n\n#use for sepertate\ntable3 %>% \n  separate(rate, c(\"cases\", \"population\"))\n\n#convert = T makes a guess at an appropriate column type\ntable3 %>% \n  separate(rate, c(\"cases\", \"population\"), convert = T)\n\n\n```\n\n###`unite()`\n\n`unite()` is the inverse of `seperate()`; it lets you combine two columns.\n\n```{r}\n#unite \ntable5\n\n#verbose; note that it drops the original columns and uses _ to combine\nunite(data = table5, col = date, century, year)\n\nunite(data = table5, col = date, century, year, sep = \"\", remove = F)\n\n#pipe version\n\ntable5 %>% \n  unite(col = date, century, year, sep = \"\")\n\n\n```\n\n### Challenge problem 2\n\n1. Take a look at `table3` and `table5`. Using either `separate()` or `unite()` make `table3` identical to `table5`. Check your work using the `identical()` fucntion. Hint you might need to look at the help pages for either `unite()` or `separate()`, taking a close look at the sep argument.\n\n\n##Other useful tidyr functions\n\n##`drop_na()`\n\n`drop_na()` lets you drop rows with missing values\n\n```{r}\nsmiths\n\nsmiths %>% drop_na\n\n```\n\n\n##`complete()`\n\n`complete()` takes a dataframe and makes implicitly missing values explicitly missing. \n\n```{r}\npopulation\n\npopulation %>% \n  filter(country == \"South Sudan\")\n\npopulation_exp_missing <- \ncomplete(population, country, year)\n\npopulation_exp_missing %>% \n  filter(country == \"South Sudan\")\n\n```\n\n\n### Challenge problem 3 \n\n1. `drop_na()` removes rows that have missing values on any column, but it can be used in a more focused way (i.e. you can drop rows that have missing data specific columns). Using the `who` dataset (from `tidyr`) make a version of that dataset that has no missing values on the columns `new_sp_m014` and `new_sp_m1524`.\n\n## Other resources and what to learn next\n\n* Hadley Wickham's excellent R for Data Science book has a number of great chapters on tidy data. I used his book to help put togther this lesson. The whole book is available for free [here](http://r4ds.had.co.nz). \n\n* Hadley Wickham's journal article on tidy data, [here](http://vita.had.co.nz/papers/tidy-data.pdf). \n\n* Check out the join functions that are part of `dplyr`. These help you combine dataframes. \n\n* The `nest()` function helps you easily create dataframes that have nested lists (i.e. what Jenny talked about last week); these are very powerful when used with `purrr`.\n\n##Solutions to challenge problems\n\n###Challenge problem 1\n\n```{r}\n#abc)\n\ntable4b %>% gather(year, cases, -country) %>% \n  summarise(mean_cases = mean(cases))\n\n#d)\n#tidy\ntable4b %>% gather(year, cases, -country) %>% \n  group_by(year) %>% \n  summarise(mean_cases = mean(cases))\n\n#non-tidy\nmean(table4b$`1999`)\nmean(table4b$`2000`)\n\ntable4b %>% summarise(mean_cases_1999 = \n                        mean(`1999`), \n                      mean_cases_2000 = \n                        mean(`2000`))\n\n\n```\n\n###Challenge problem 2\n\n```{r}\ntable3\ntable5\n\nnew_table3 <- \ntable3 %>% \n  separate(year, into = c(\"century\", \"year\"), sep = 2)\n\nidentical(new_table3, table5)\n```\n\n###Challenge problem 3\n\n```{r}\nwho %>% drop_na(new_sp_m014, new_sp_m1524) \n```\n",
    "created" : 1471466328043.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1867413910",
    "id" : "ED9F67B3",
    "lastKnownWriteTime" : 1471569393,
    "last_content_update" : 1471569688100,
    "path" : "~/SpiderOak Hive/Class/study_group/tidyr_lesson/tidyr_lesson.Rmd",
    "project_path" : "tidyr_lesson.Rmd",
    "properties" : {
        "chunk_output_type" : "inline",
        "tempName" : "Untitled2"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}